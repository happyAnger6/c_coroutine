# C coroutine调度器实现

## CMP模型

+ C: coroutine实体,关联执行的任务处理.
+ M: 对应实际的os线程, 一个M必须绑定唯一个P,来执行P上本地队列中的协程.
+ P: 对应实际的cpu,每个P都有自己的本地队列用于存放待调度协程  
  P使用M来运行协程,一个P可能对应多个M,当M上运行的协程阻塞时会增加P上的M个数.

### M主循环流程

1. 从M关联的p的本地队列中获取可运行的coroutine.如果获取到执行步骤2,否则执行步骤3
2. 调度运行刚刚获取到的coroutine.
3. 查询全局队列中是否有可运行的coroutine,如果有执行步骤4,否则执行步骤5
4. 从全局队列中获

gcc_util.c: x_cgo_thread_start
gcc_linux_amd64.c: threadentry-->crosscall_amd64(ts.fn)
gcc_amd64.S: crosscall_amd64-->	call *%rdi	/* fn */


### main

asm_amd64.s: _rt0_amd64(SB)
89:runtime.rt0_go